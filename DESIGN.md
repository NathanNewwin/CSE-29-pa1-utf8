1. The size of UTF-32 encoding will be larger than UTF-8 encoding since UTF-32 always encodes in 4 bytes. For example, valid ASCII will always be 4 bytes long in UTF-32, but it will only be 1 byte when using UTF-8. As stated in one of the lectures, UTF-8 was made for backwards compatability. A program that expected ASCII would only be reading 1 byte while the program might get confused when presented with 4 bytes as an ASCII.

2. If you are byte indexing a string and end up at a multi-byte code point, you might not know if you are at a start byte or in the middle of a muli-byte code point. Lets take a random multi-byte code point and split it up (1111XXXX 10XXXXXX 10XXXXXX 10XXXXXX). When we index to the second byte of this codepoint, we know that it is a trailing byte since it starts with 10. If the 10 was not there and it was maybe 00101001, we don't know if it is a trailing byte or a starting byte.

REGRADE QUESTIONS
1. The codepoint becomes 33 which is equal to '!'. 11100000 becomes 0000, 10000000 becomes 000000, and 10100001 becomes 1000001. Adding them together makes 000000000000100001.
2. ! can be encoded in UTF-16 where it becomes 0x0021. In UTF-32, it is encodes as 0x00000021. Regular UTF-8(not overlong UTF-8) and ISO-8859-1 encoding makes ! be 00100001 or 0x21.
3. The cent sign can only be encoded in UTF-8, UTF-16, and ISO-8859-1.
4. Overlong encoding allows characters to be longer than necessary which means more bytes are being used. The given example shows how a 1 byte character can be represented in 3 bytes. As stated in a lecture, having too many encodings can lead to compatability issues with older software. If the encoding doesn't have backwards compatability, the program might just display random text instead of the desired character. Overlong encoding also possess a security risk when it comes to bypassing input filters. As an example, you are creating a program that allows file searching, but you don't want people to access important files. Usually "/" is filtered out by its 1 byte representation, but overlong encoding can bypass this filter.